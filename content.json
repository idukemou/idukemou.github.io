{"pages":[{"title":"about","text":"1. 敲过代码，搬过砖2. 教过学生，讲过课3. 做过管理，创着业","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"FlappyBird开发笔记01","text":"项目目录搭建 自定义目录搭建（随便创建） 优点，前期开发没有学习成本 缺点，不利于团队协作开发 应用场景：原生开发（20%） 工具限定的（前端框架、java、android、IOS） 框架开发 （80%） + 本地化resource 资源（图片，音频，视频） 学习成本比较高 游戏，软件逻辑 软件界面的搭建静态(不变的)界面： html css 1、标签数量固定动态变化的元素 ： JS动态创建 1、数量不确定的，动态变化 和界面元素的交互动作（JS） 移动端等比例缩放控制 vw : 当前屏幕宽度的1%，与盒子父级尺寸无关 vh : 当前屏幕高度的1%，与盒子父级尺寸无关.box{ width:100vw; /*占满屏幕宽度*/ height:100vh; /*占满屏幕高度*/ margin-top:10vh; /*高度方向等比例移动*/ margin-left:10vw; /*宽度方向等比例移动*/} 推荐使用方法 宽度方向的尺寸，一般只用vw 高度方向的尺寸，一般用vh 页面中引入图片的方式 background-image:背景图 不占用盒子空间。图片上文字，或其他盒子，优先考虑使用背景图 img：本身就是一个图片标签。尺寸设置可以自适应。常用在图片文字分离场景 游戏界面的布局 改变盒子位置的时候，有两种选择 margin 位置改变。 联动效果 定位（绝对定位、固定定位） 互相没有影响推荐使用 定位 绝对定位应用（定位父级）div{ position:static ; //不可以做定位父级 /* 以下皆可 */ position:absolute ; position:fixed; /* 优先推荐 */ position:relative;} relative定位盒子特性relative可以同定位来改变盒子位置，同时对原始页面没有任何影响 定位特性.box{ position:absolute; /* 不设置宽度 */ left:0; right:0; /* 将整个盒子拉开 */} left right bottom top设置的都是盒子的边到定位父级边之间距离 盒子间隙特性同行排列的盒子，默认的会解析，文档中标签之间的回车键，变成页面中的一个空隙 消除办法： 给父级设置 $font-size:0$ CSS动画特性/* 定义动画关键帧 */ @keyframes 名称{ 0%{样式：值} ... 100%{样式} } 定义了样式的切换点 /* 使用 */ .box{ animation:move 2s infinite alternate ease; /* animation: 动画关键帧名称 动画时间 动画播放次数 inifnite 无限次 动画播放顺序 alternate 交替播放 0%-100%-0% 动画时间曲线 linear 匀速 ease(默认) */ } 作业 完成小鸟背景切换动画 完成草皮移动动画","link":"/2021/07/06/FlappyBird%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B001/"},{"title":"FlappyBird开发笔记02","text":"点击事件监听监听的是标签被用户的点击行为 &lt;style&gt; .box{ width: 100px; height: 100px; background:red; }&lt;/style&gt;&lt;div class=\"box\" onclick=\"start()\"&gt;哈哈&lt;/div&gt;&lt;script&gt;// 定义start()// 监听点击事件第一种：在标签行间直接编写 onclick=\"处理函数()\"// 处理函数在script标签中定义 function start(){ alert(\"嘿嘿\") } 通过JS动态获取标签，设置样式 JS获取标签，通过ID&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;script&gt; // 直接使用符号box来获取标签 console.log(box);&lt;/script&gt; JS动态修改盒子样式&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;script&gt; // ID.style.样式名 = \"样式值\" box.style.backgroundColor = \"red\"; box.style.color = \"blue\"; box.style.fontSize = \"12px\";&lt;/script&gt; JS控制盒子位移代码//通过JS代码移动盒子的套路 // 1、获取当前盒子位置 var now_x = box.offsetLeft; var now_y = box.offsetTop; // 2、对位置数据进行改变 now_x += 50; now_y += 50; // 3、对位置样式进行改变 box.style.left = now_x + \"px\"; box.style.top = now_y + \"px\"; JS 定时器&lt;!-- JS定时器，能够允许按照一定的时间间隔，去重复执行 指定代码段。并且可以通过方法，对定时器进行停止 定时器启动： var timer = setInterval(function(){ 要循环执行的代码块 },时间) 定时器停止 clearInterval(timer)--&gt;&lt;script&gt; var count = 0; var timer = setInterval(function(){ console.log(count) count++; if(count &gt;= 5){ // 停止定时器 clearInterval(timer) } },1000)&lt;/script&gt; JS动态获取盒子的尺寸 盒子高度： offsetHeight 盒子宽度： offsetWidth 盒子top: offsetTop 盒子left: offsetLeft 事件冒泡相同类型的事件处理方法，就会被调用，表现为，点击子级，而触发父级的点击事件 阻止事件冒泡&lt;div class=\"father\" onclick=\"fn1()\"&gt; &lt;div class=\"son\" onclick=\"fn(event)\"&gt;&lt;/div&gt;&lt;script&gt; function fn(e){ // 阻止事件冒泡 e.stopPropagation(); }&lt;/script&gt; 清空所有定时器（原理）边界监测 上限条件： top &lt;= 0 下限条件： top &gt;= 草皮top - 小鸟height","link":"/2021/07/06/FlappyBird%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B002/"},{"title":"FlappyBird开发笔记03","text":"停止定时器原理每个启动的定时器，都会返回一个number值，是1开始进行递增 timer1 = setInterval(function(){},1000) //timer = 1 timer2 = setInterval(function(){},1000) //timer = 2 timer3 = setInterval(function(){},1000) //timer = 3// 停止定时器 clearInterval(number) //填1 停止 timer1 clearInterval(2) //填2 停止 timer2 clearInterval(3) //填3 停止 timer3 清除所有定时器// 首先创建一个新的定时器，记录返回值，其返回值特点，比当前页面中所有定时器总数 + 1 var length = setInterval(function(){},1)// for循环遍历，将所有的定时器停止 for(var i = 1; i &lt;= length;i++){ clearInterval(i) }","link":"/2021/07/06/FlappyBird%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B003/"},{"title":"Docker一键部署dnmp","text":"一直想用docker部署一套开发环境，可能是因为太懒的缘故，觉得在Mac上有一堆成熟的套件可用，比如：xampp、mamp等等。就没有动手。近来，自己的Mac更新了最新测试版系统，mamp由于未得到更新，所以一直处以闪崩状态，不得已想到了docker… 1.准备工作 1.安装环境：Mac OS 2.node版本：latest 3.预先安装：Homebrew 2.预先安装：Homebrew由于众所周知的原因，Homebrew官网的安装命令极易导致： Failed to connect to raw.githubusercontent.com port 443: Connection refused 下面转载大神写的安装脚本，十分方便。打开terminal，粘贴下属命令即可等待安装： /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" 3.关于docker3.1. 什么是docker？Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 3.2. docker常用的标准化套件 1.Docker Engine 2.Docker CLI Client 3.Docker Compose 4.Docker Machine 3.3. docker安装命令通过第二本我们顺利的安装了homebrew，所以下面通过brew安装docker： brew cask install docker 4.快速使用4.1. 本地安装 git Docker(系统需为Linux，Windows 10 Build 15063+，或MacOS 10.12+，且必须要64位） docker-compose 1.7.0+4.2. clone项目：$ git clone https://github.com/yeszao/dnmp.git 4.3. 如果不是root用户，还需将当前用户加入docker用户组：$ sudo gpasswd -a ${USER} docker 4.4. 拷贝并命名配置文件（Windows系统请用copy命令），启动：$ cd dnmp # 进入项目目录$ cp env.sample .env # 复制环境变量文件$ cp docker-compose.sample.yml docker-compose.yml # 复制 docker-compose 配置文件。默认启动3个服务： # Nginx、PHP7和MySQL8。要开启更多其他服务，如Redis、 # PHP5.6、PHP5.4、MongoDB，ElasticSearch等，请删 # 除服务块前的注释$ docker-compose up # 启动 在浏览器中访问：http://localhost或https://localhost(自签名HTTPS演示)就能看到效果，PHP代码在文件./www/localhost/index.php。 5.PHP和扩展5.1. 切换Nginx使用的PHP版本首先，需要启动其他版本的PHP，比如PHP5.4，那就先在docker-compose.yml文件中删除PHP5.4前面的注释，再启动PHP5.4容器。 PHP5.4启动后，打开Nginx 配置，修改fastcgi_pass的主机地址，由php改为php54，如下： fastcgi_pass php:9000; 为： fastcgi_pass php54:9000; 其中 php 和 php54 是docker-compose.yml文件中服务器的名称。 最后，重启 Nginx 生效。 $ docker exec -it nginx nginx -s reload 这里两个nginx，第一个是容器名，第二个是容器中的nginx程序。 5.2. 安装PHP扩展PHP的很多功能都是通过扩展实现，而安装扩展是一个略费时间的过程，所以，除PHP内置扩展外，在env.sample文件中我们仅默认安装少量扩展，如果要安装更多扩展，请打开你的.env文件修改如下的PHP配置，增加需要的PHP扩展： PHP_EXTENSIONS=pdo_mysql,opcache,redis # PHP 要安装的扩展列表，英文逗号隔开PHP54_EXTENSIONS=opcache,redis # PHP 5.4要安装的扩展列表，英文逗号隔开 然后重新build PHP镜像。 docker-compose build php 可用的扩展请看同文件的env.sample注释块说明。 5.3. 快速安装php扩展5.3.1. 进入容器:docker exec -it php /bin/shinstall-php-extensions apcu 5.3.2. 支持快速安装扩展列表 Extension PHP 5.5 PHP 5.6 PHP 7.0 PHP 7.1 PHP 7.2 PHP 7.3 PHP 7.4 PHP 8.0 amqp ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ apcu ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ apcu_bc ✓ ✓ ✓ ✓ ✓ ast ✓ ✓ ✓ ✓ ✓ ✓ bcmath ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ bz2 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ calendar ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ cmark ✓ ✓ ✓ ✓ ✓ csv ✓ ✓ ✓ dba ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ decimal ✓ ✓ ✓ ✓ ✓ ✓ ds ✓ ✓ ✓ ✓ ✓ ✓ enchant* ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ev ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ excimer ✓ ✓ ✓ ✓ ✓ exif ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ffi ✓ ✓ gd ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gearman ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ geoip ✓ ✓ ✓ ✓ ✓ ✓ ✓ geospatial ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gettext ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gmagick ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gmp ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gnupg ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ grpc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ http ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ igbinary ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ imagick ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ imap ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ inotify ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ interbase ✓ ✓ ✓ ✓ ✓ ✓ intl ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ioncube_loader ✓ ✓ ✓ ✓ ✓ ✓ ✓ json_post ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ldap ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mailparse ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ maxminddb ✓ ✓ ✓ ✓ mcrypt ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ memcache ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ memcached ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mongo ✓ ✓ mongodb ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mosquitto ✓ ✓ ✓ ✓ ✓ ✓ ✓ msgpack ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mssql ✓ ✓ mysql ✓ ✓ mysqli ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ oauth ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ oci8 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ odbc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ opcache ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ opencensus ✓ ✓ ✓ ✓ ✓ parallel* ✓ ✓ ✓ ✓ pcntl ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pcov ✓ ✓ ✓ ✓ ✓ ✓ pdo_dblib ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_firebird ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_mysql ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_oci ✓ ✓ ✓ ✓ ✓ ✓ pdo_odbc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_pgsql ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_sqlsrv* ✓ ✓ ✓ ✓ ✓ ✓ pgsql ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ propro ✓ ✓ ✓ ✓ ✓ ✓ ✓ protobuf ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pspell ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pthreads* ✓ ✓ ✓ raphf ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ rdkafka ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ recode ✓ ✓ ✓ ✓ ✓ ✓ redis ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ seaslog ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ shmop ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ smbclient ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ snmp ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ snuffleupagus ✓ ✓ ✓ ✓ ✓ ✓ soap ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sockets ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ solr ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sqlsrv* ✓ ✓ ✓ ✓ ✓ ✓ ssh2 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ swoole ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sybase_ct ✓ ✓ sysvmsg ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sysvsem ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sysvshm ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ tensor ✓ ✓ ✓ ✓ tidy ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ timezonedb ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ uopz ✓ ✓ ✓ ✓ ✓ ✓ ✓ uuid ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ vips* ✓ ✓ ✓ ✓ ✓ ✓ wddx ✓ ✓ ✓ ✓ ✓ ✓ xdebug ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ xhprof ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ xlswriter ✓ ✓ ✓ ✓ ✓ ✓ xmlrpc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ xsl ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ yaml ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ yar ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ zip ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ zookeeper ✓ ✓ ✓ ✓ ✓ ✓ ✓ zstd ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ 此扩展来自https://github.com/mlocati/docker-php-extension-installer参考示例文件 5.4. Host中使用php命令行（php-cli）5.4.1. 参考bash.alias.sample示例文件，将对应 php cli 函数拷贝到主机的 ~/.bashrc文件。5.4.2. 让文件起效：source ~/.bashrc 5.4.3. 然后就可以在主机中执行php命令了：~ php -vPHP 7.2.13 (cli) (built: Dec 21 2018 02:22:47) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.13, Copyright (c) 1999-2018, by Zend Technologies with Xdebug v2.6.1, Copyright (c) 2002-2018, by Derick Rethans 5.5. 使用composer方法1：主机中使用composer命令 5.5.1. 确定composer缓存的路径。比如，我的dnmp下载在~/dnmp目录，那composer的缓存路径就是~/dnmp/data/composer。5.5.2. 参考bash.alias.sample示例文件，将对应 php composer 函数拷贝到主机的 ~/.bashrc文件。 这里需要注意的是，示例文件中的~/dnmp/data/composer目录需是第一步确定的目录。 5.5.3. 让文件起效：source ~/.bashrc 5.5.4. 在主机的任何目录下就能用composer了：cd ~/dnmp/www/composer create-project yeszao/fastphp project --no-dev 5.5.5. （可选）第一次使用 composer 会在 ~/dnmp/data/composer 目录下生成一个config.json文件，可以在这个文件中指定国内仓库，例如：{ \"config\": {}, \"repositories\": { \"packagist\": { \"type\": \"composer\", \"url\": \"https://packagist.laravel-china.org\" } }} 方法二：容器内使用composer命令 还有另外一种方式，就是进入容器，再执行composer命令，以PHP7容器为例： docker exec -it php /bin/shcd /www/localhostcomposer update 6. 管理命令6.1. 服务器启动和构建命令如需管理服务，请在命令后面加上服务器名称，例如： $ docker-compose up # 创建并且启动所有容器$ docker-compose up -d # 创建并且后台运行方式启动所有容器$ docker-compose up nginx php mysql # 创建并且启动nginx、php、mysql的多个容器$ docker-compose up -d nginx php mysql # 创建并且已后台运行的方式启动nginx、php、mysql容器$ docker-compose start php # 启动服务$ docker-compose stop php # 停止服务$ docker-compose restart php # 重启服务$ docker-compose build php # 构建或者重新构建服务$ docker-compose rm php # 删除并且停止php容器$ docker-compose down # 停止并删除容器，网络，图像和挂载卷 6.2. 添加快捷命令在开发的时候，我们可能经常使用docker exec -it进入到容器中，把常用的做成命令别名是个省事的方法。 首先，在主机中查看可用的容器： $ docker ps # 查看所有运行中的容器$ docker ps -a # 所有容器 输出的NAMES那一列就是容器的名称，如果使用默认配置，那么名称就是nginx、php、php56、mysql等。 然后，打开~/.bashrc或者~/.zshrc文件，加上： alias dnginx='docker exec -it nginx /bin/sh'alias dphp='docker exec -it php /bin/sh'alias dphp56='docker exec -it php56 /bin/sh'alias dphp54='docker exec -it php54 /bin/sh'alias dmysql='docker exec -it mysql /bin/bash'alias dredis='docker exec -it redis /bin/sh' 下次进入容器就非常快捷了，如进入php容器： $ dphp 6.3. 查看docker网络ifconfig docker0 用于填写extra_hosts容器访问宿主机的hosts地址 7. 使用LogLog文件生成的位置依赖于conf下各log配置的值。 7.1. Nginx日志Nginx日志是我们用得最多的日志，所以我们单独放在根目录log下。 log会目录映射Nginx容器的/var/log/nginx目录，所以在Nginx配置文件中，需要输出log的位置，我们需要配置到/var/log/nginx目录，如： error_log /var/log/nginx/nginx.localhost.error.log warn; 7.2. PHP-FPM日志大部分情况下，PHP-FPM的日志都会输出到Nginx的日志中，所以不需要额外配置。 另外，建议直接在PHP中打开错误日志： error_reporting(E_ALL);ini_set('error_reporting', 'on');ini_set('display_errors', 'on'); 如果确实需要，可按一下步骤开启（在容器中）。 7.2.1. 进入容器，创建日志文件并修改权限：$ docker exec -it php /bin/sh$ mkdir /var/log/php$ cd /var/log/php$ touch php-fpm.error.log$ chmod a+w php-fpm.error.log 7.2.2. 主机上打开并修改PHP-FPM的配置文件conf/php-fpm.conf，找到如下一行，删除注释，并改值为：php_admin_value[error_log] = /var/log/php/php-fpm.error.log 7.2.3. 重启PHP-FPM容器。7.3. MySQL日志因为MySQL容器中的MySQL使用的是mysql用户启动，它无法自行在/var/log下的增加日志文件。所以，我们把MySQL的日志放在与data一样的目录，即项目的mysql目录下，对应容器中的/var/lib/mysql/目录。 slow-query-log-file = /var/lib/mysql/mysql.slow.loglog-error = /var/lib/mysql/mysql.error.log 以上是mysql.conf中的日志文件的配置。 8. 数据库管理本项目默认在docker-compose.yml中不开启了用于MySQL在线管理的phpMyAdmin，以及用于redis在线管理的phpRedisAdmin，可以根据需要修改或删除。 8.1 phpMyAdminphpMyAdmin容器映射到主机的端口地址是：8080，所以主机上访问phpMyAdmin的地址是： http://localhost:8080 MySQL连接信息： host：(本项目的MySQL容器网络) port：3306 username：（手动在phpmyadmin界面输入） password：（手动在phpmyadmin界面输入） 8.2 phpRedisAdminphpRedisAdmin容器映射到主机的端口地址是：8081，所以主机上访问phpMyAdmin的地址是： http://localhost:8081 Redis连接信息如下： host: (本项目的Redis容器网络) port: 6379 9. 在正式环境中安全使用要在正式环境中使用，请： 在php.ini中关闭XDebug调试 增强MySQL数据库访问的安全策略 增强redis访问的安全策略 10. 常见问题10.1. 如何在PHP代码中使用curl？参考这个issue：https://github.com/yeszao/dnmp/issues/91 10.2. Docker使用cron定时任务Docker使用cron定时任务 10.3. Docker容器时间容器时间在.env文件中配置TZ变量，所有支持的时区请看时区列表·维基百科或者PHP所支持的时区列表·PHP官网。 10.4. 如何连接MySQL和Redis服务器这要分两种情况， 第一种情况，在PHP代码中。 // 连接MySQL$dbh = new PDO('mysql:host=mysql;dbname=mysql', 'root', '123456');// 连接Redis$redis = new Redis();$redis-&gt;connect('redis', 6379); 因为容器与容器是expose端口联通的，而且在同一个networks下，所以连接的host参数直接用容器名称，port参数就是容器内部的端口。更多请参考《docker-compose ports和expose的区别》。 第二种情况，在主机中通过命令行或者Navicat等工具连接。主机要连接mysql和redis的话，要求容器必须经过ports把端口映射到主机了。以 mysql 为例，docker-compose.yml文件中有这样的ports配置：3306:3306，就是主机的3306和容器的3306端口形成了映射，所以我们可以这样连接： $ mysql -h127.0.0.1 -uroot -p123456 -P3306$ redis-cli -h127.0.0.1 这里host参数不能用localhost是因为它默认是通过sock文件与mysql通信，而容器与主机文件系统已经隔离，所以需要通过TCP方式连接，所以需要指定IP。 10.5. 容器内的php如何连接宿主机MySQL10.5.1. 宿主机执行ifconfig docker0得到inet就是要连接的ip地址$ ifconfig docker0docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 ... 10.5.2. 运行宿主机Mysql命令行 mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; mysql&gt;flush privileges;// 其中各字符的含义：// *.* 对任意数据库任意表有效// \"root\" \"123456\" 是数据库用户名和密码// '%' 允许访问数据库的IP地址，%意思是任意IP，也可以指定IP// flush privileges 刷新权限信息 10.5.3. 接着直接php容器使用172.0.17.1:3306连接即可","link":"/2021/07/07/Docker%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2dnmp/"}],"tags":[{"name":"FlappyBird","slug":"FlappyBird","link":"/tags/FlappyBird/"},{"name":"web前端","slug":"web前端","link":"/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"dnmp","slug":"dnmp","link":"/tags/dnmp/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"}]}
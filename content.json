{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"1. 敲过代码，搬过砖2. 教过学生，讲过课3. 做过管理，创着业","link":"/about/index.html"}],"posts":[{"title":"FlappyBird开发笔记01","text":"项目目录搭建 自定义目录搭建（随便创建） 优点，前期开发没有学习成本 缺点，不利于团队协作开发 应用场景：原生开发（20%） 工具限定的（前端框架、java、android、IOS） 框架开发 （80%） + 本地化resource 资源（图片，音频，视频） 学习成本比较高 游戏，软件逻辑 软件界面的搭建静态(不变的)界面： html css 1、标签数量固定动态变化的元素 ： JS动态创建 1、数量不确定的，动态变化 和界面元素的交互动作（JS） 移动端等比例缩放控制 vw : 当前屏幕宽度的1%，与盒子父级尺寸无关 vh : 当前屏幕高度的1%，与盒子父级尺寸无关.box{ width:100vw; /*占满屏幕宽度*/ height:100vh; /*占满屏幕高度*/ margin-top:10vh; /*高度方向等比例移动*/ margin-left:10vw; /*宽度方向等比例移动*/} 推荐使用方法 宽度方向的尺寸，一般只用vw 高度方向的尺寸，一般用vh 页面中引入图片的方式 background-image:背景图 不占用盒子空间。图片上文字，或其他盒子，优先考虑使用背景图 img：本身就是一个图片标签。尺寸设置可以自适应。常用在图片文字分离场景 游戏界面的布局 改变盒子位置的时候，有两种选择 margin 位置改变。 联动效果 定位（绝对定位、固定定位） 互相没有影响推荐使用 定位 绝对定位应用（定位父级）div{ position:static ; //不可以做定位父级 /* 以下皆可 */ position:absolute ; position:fixed; /* 优先推荐 */ position:relative;} relative定位盒子特性relative可以同定位来改变盒子位置，同时对原始页面没有任何影响 定位特性.box{ position:absolute; /* 不设置宽度 */ left:0; right:0; /* 将整个盒子拉开 */} left right bottom top设置的都是盒子的边到定位父级边之间距离 盒子间隙特性同行排列的盒子，默认的会解析，文档中标签之间的回车键，变成页面中的一个空隙 消除办法： 给父级设置 $font-size:0$ CSS动画特性/* 定义动画关键帧 */ @keyframes 名称{ 0%{样式：值} ... 100%{样式} } 定义了样式的切换点 /* 使用 */ .box{ animation:move 2s infinite alternate ease; /* animation: 动画关键帧名称 动画时间 动画播放次数 inifnite 无限次 动画播放顺序 alternate 交替播放 0%-100%-0% 动画时间曲线 linear 匀速 ease(默认) */ } 作业 完成小鸟背景切换动画 完成草皮移动动画","link":"/2021/07/06/FlappyBird%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B001/"},{"title":"FlappyBird开发笔记03","text":"停止定时器原理每个启动的定时器，都会返回一个number值，是1开始进行递增 timer1 = setInterval(function(){},1000) //timer = 1 timer2 = setInterval(function(){},1000) //timer = 2 timer3 = setInterval(function(){},1000) //timer = 3// 停止定时器 clearInterval(number) //填1 停止 timer1 clearInterval(2) //填2 停止 timer2 clearInterval(3) //填3 停止 timer3 清除所有定时器// 首先创建一个新的定时器，记录返回值，其返回值特点，比当前页面中所有定时器总数 + 1 var length = setInterval(function(){},1)// for循环遍历，将所有的定时器停止 for(var i = 1; i &lt;= length;i++){ clearInterval(i) }","link":"/2021/07/06/FlappyBird%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B003/"},{"title":"FlappyBird开发笔记02","text":"点击事件监听监听的是标签被用户的点击行为 &lt;style&gt; .box{ width: 100px; height: 100px; background:red; }&lt;/style&gt;&lt;div class=\"box\" onclick=\"start()\"&gt;哈哈&lt;/div&gt;&lt;script&gt;// 定义start()// 监听点击事件第一种：在标签行间直接编写 onclick=\"处理函数()\"// 处理函数在script标签中定义 function start(){ alert(\"嘿嘿\") } 通过JS动态获取标签，设置样式 JS获取标签，通过ID&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;script&gt; // 直接使用符号box来获取标签 console.log(box);&lt;/script&gt; JS动态修改盒子样式&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;script&gt; // ID.style.样式名 = \"样式值\" box.style.backgroundColor = \"red\"; box.style.color = \"blue\"; box.style.fontSize = \"12px\";&lt;/script&gt; JS控制盒子位移代码//通过JS代码移动盒子的套路 // 1、获取当前盒子位置 var now_x = box.offsetLeft; var now_y = box.offsetTop; // 2、对位置数据进行改变 now_x += 50; now_y += 50; // 3、对位置样式进行改变 box.style.left = now_x + \"px\"; box.style.top = now_y + \"px\"; JS 定时器&lt;!-- JS定时器，能够允许按照一定的时间间隔，去重复执行 指定代码段。并且可以通过方法，对定时器进行停止 定时器启动： var timer = setInterval(function(){ 要循环执行的代码块 },时间) 定时器停止 clearInterval(timer)--&gt;&lt;script&gt; var count = 0; var timer = setInterval(function(){ console.log(count) count++; if(count &gt;= 5){ // 停止定时器 clearInterval(timer) } },1000)&lt;/script&gt; JS动态获取盒子的尺寸 盒子高度： offsetHeight 盒子宽度： offsetWidth 盒子top: offsetTop 盒子left: offsetLeft 事件冒泡相同类型的事件处理方法，就会被调用，表现为，点击子级，而触发父级的点击事件 阻止事件冒泡&lt;div class=\"father\" onclick=\"fn1()\"&gt; &lt;div class=\"son\" onclick=\"fn(event)\"&gt;&lt;/div&gt;&lt;script&gt; function fn(e){ // 阻止事件冒泡 e.stopPropagation(); }&lt;/script&gt; 清空所有定时器（原理）边界监测 上限条件： top &lt;= 0 下限条件： top &gt;= 草皮top - 小鸟height","link":"/2021/07/06/FlappyBird%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B002/"},{"title":"Docker一键部署dnmp","text":"一直想用docker部署一套开发环境，可能是因为太懒的缘故，觉得在Mac上有一堆成熟的套件可用，比如：xampp、mamp等等。就没有动手。近来，自己的Mac更新了最新测试版系统，mamp由于未得到更新，所以一直处以闪崩状态，不得已想到了docker… 1.准备工作 1.安装环境：Mac OS 2.node版本：latest 3.预先安装：Homebrew 2.预先安装：Homebrew由于众所周知的原因，Homebrew官网的安装命令极易导致： Failed to connect to raw.githubusercontent.com port 443: Connection refused 下面转载大神写的安装脚本，十分方便。打开terminal，粘贴下属命令即可等待安装： /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" 3.关于docker3.1. 什么是docker？Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 3.2. docker常用的标准化套件 1.Docker Engine 2.Docker CLI Client 3.Docker Compose 4.Docker Machine 3.3. docker安装命令通过第二本我们顺利的安装了homebrew，所以下面通过brew安装docker： brew cask install docker 4.快速使用4.1. 本地安装 git Docker(系统需为Linux，Windows 10 Build 15063+，或MacOS 10.12+，且必须要64位） docker-compose 1.7.0+ 4.2. clone项目：$ git clone https://github.com/yeszao/dnmp.git 4.3. 如果不是root用户，还需将当前用户加入docker用户组：$ sudo gpasswd -a ${USER} docker 4.4. 拷贝并命名配置文件（Windows系统请用copy命令），启动：$ cd dnmp # 进入项目目录$ cp env.sample .env # 复制环境变量文件$ cp docker-compose.sample.yml docker-compose.yml # 复制 docker-compose 配置文件。默认启动3个服务： # Nginx、PHP7和MySQL8。要开启更多其他服务，如Redis、 # PHP5.6、PHP5.4、MongoDB，ElasticSearch等，请删 # 除服务块前的注释$ docker-compose up # 启动 4.5. 在浏览器中访问：http://localhost或https://localhost(自签名HTTPS演示)就能看到效果，PHP代码在文件./www/localhost/index.php。 5.PHP和扩展5.1. 切换Nginx使用的PHP版本首先，需要启动其他版本的PHP，比如PHP5.4，那就先在docker-compose.yml文件中删除PHP5.4前面的注释，再启动PHP5.4容器。 PHP5.4启动后，打开Nginx 配置，修改fastcgi_pass的主机地址，由php改为php54，如下： fastcgi_pass php:9000; 为： fastcgi_pass php54:9000; 其中 php 和 php54 是docker-compose.yml文件中服务器的名称。 最后，重启 Nginx 生效。 $ docker exec -it nginx nginx -s reload 这里两个nginx，第一个是容器名，第二个是容器中的nginx程序。 5.2. 安装PHP扩展PHP的很多功能都是通过扩展实现，而安装扩展是一个略费时间的过程，所以，除PHP内置扩展外，在env.sample文件中我们仅默认安装少量扩展，如果要安装更多扩展，请打开你的.env文件修改如下的PHP配置，增加需要的PHP扩展： PHP_EXTENSIONS=pdo_mysql,opcache,redis # PHP 要安装的扩展列表，英文逗号隔开PHP54_EXTENSIONS=opcache,redis # PHP 5.4要安装的扩展列表，英文逗号隔开 然后重新build PHP镜像。 docker-compose build php 可用的扩展请看同文件的env.sample注释块说明。 5.3. 快速安装php扩展5.3.1. 进入容器:docker exec -it php /bin/shinstall-php-extensions apcu 5.3.2. 支持快速安装扩展列表 Extension PHP 5.5 PHP 5.6 PHP 7.0 PHP 7.1 PHP 7.2 PHP 7.3 PHP 7.4 PHP 8.0 amqp ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ apcu ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ apcu_bc ✓ ✓ ✓ ✓ ✓ ast ✓ ✓ ✓ ✓ ✓ ✓ bcmath ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ bz2 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ calendar ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ cmark ✓ ✓ ✓ ✓ ✓ csv ✓ ✓ ✓ dba ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ decimal ✓ ✓ ✓ ✓ ✓ ✓ ds ✓ ✓ ✓ ✓ ✓ ✓ enchant* ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ev ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ excimer ✓ ✓ ✓ ✓ ✓ exif ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ffi ✓ ✓ gd ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gearman ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ geoip ✓ ✓ ✓ ✓ ✓ ✓ ✓ geospatial ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gettext ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gmagick ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gmp ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ gnupg ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ grpc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ http ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ igbinary ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ imagick ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ imap ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ inotify ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ interbase ✓ ✓ ✓ ✓ ✓ ✓ intl ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ioncube_loader ✓ ✓ ✓ ✓ ✓ ✓ ✓ json_post ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ldap ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mailparse ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ maxminddb ✓ ✓ ✓ ✓ mcrypt ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ memcache ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ memcached ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mongo ✓ ✓ mongodb ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mosquitto ✓ ✓ ✓ ✓ ✓ ✓ ✓ msgpack ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ mssql ✓ ✓ mysql ✓ ✓ mysqli ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ oauth ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ oci8 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ odbc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ opcache ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ opencensus ✓ ✓ ✓ ✓ ✓ parallel* ✓ ✓ ✓ ✓ pcntl ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pcov ✓ ✓ ✓ ✓ ✓ ✓ pdo_dblib ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_firebird ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_mysql ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_oci ✓ ✓ ✓ ✓ ✓ ✓ pdo_odbc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_pgsql ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pdo_sqlsrv* ✓ ✓ ✓ ✓ ✓ ✓ pgsql ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ propro ✓ ✓ ✓ ✓ ✓ ✓ ✓ protobuf ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pspell ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ pthreads* ✓ ✓ ✓ raphf ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ rdkafka ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ recode ✓ ✓ ✓ ✓ ✓ ✓ redis ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ seaslog ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ shmop ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ smbclient ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ snmp ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ snuffleupagus ✓ ✓ ✓ ✓ ✓ ✓ soap ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sockets ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ solr ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sqlsrv* ✓ ✓ ✓ ✓ ✓ ✓ ssh2 ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ swoole ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sybase_ct ✓ ✓ sysvmsg ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sysvsem ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ sysvshm ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ tensor ✓ ✓ ✓ ✓ tidy ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ timezonedb ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ uopz ✓ ✓ ✓ ✓ ✓ ✓ ✓ uuid ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ vips* ✓ ✓ ✓ ✓ ✓ ✓ wddx ✓ ✓ ✓ ✓ ✓ ✓ xdebug ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ xhprof ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ xlswriter ✓ ✓ ✓ ✓ ✓ ✓ xmlrpc ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ xsl ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ yaml ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ yar ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ zip ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ zookeeper ✓ ✓ ✓ ✓ ✓ ✓ ✓ zstd ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ 此扩展来自https://github.com/mlocati/docker-php-extension-installer参考示例文件 5.4. Host中使用php命令行（php-cli）5.4.1. 参考bash.alias.sample示例文件，将对应 php cli 函数拷贝到主机的 ~/.bashrc文件。5.4.2. 让文件起效：source ~/.bashrc 5.4.3. 然后就可以在主机中执行php命令了：~ php -vPHP 7.2.13 (cli) (built: Dec 21 2018 02:22:47) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.13, Copyright (c) 1999-2018, by Zend Technologies with Xdebug v2.6.1, Copyright (c) 2002-2018, by Derick Rethans 5.5. 使用composer方法1：主机中使用composer命令 5.5.1. 确定composer缓存的路径。比如，我的dnmp下载在~/dnmp目录，那composer的缓存路径就是~/dnmp/data/composer。5.5.2. 参考bash.alias.sample示例文件，将对应 php composer 函数拷贝到主机的 ~/.bashrc文件。 这里需要注意的是，示例文件中的~/dnmp/data/composer目录需是第一步确定的目录。 5.5.3. 让文件起效：source ~/.bashrc 5.5.4. 在主机的任何目录下就能用composer了：cd ~/dnmp/www/composer create-project yeszao/fastphp project --no-dev 5.5.5. （可选）第一次使用 composer 会在 ~/dnmp/data/composer 目录下生成一个config.json文件，可以在这个文件中指定国内仓库，例如：{ \"config\": {}, \"repositories\": { \"packagist\": { \"type\": \"composer\", \"url\": \"https://packagist.laravel-china.org\" } }} 方法二：容器内使用composer命令 还有另外一种方式，就是进入容器，再执行composer命令，以PHP7容器为例： docker exec -it php /bin/shcd /www/localhostcomposer update 6. 管理命令6.1. 服务器启动和构建命令如需管理服务，请在命令后面加上服务器名称，例如： $ docker-compose up # 创建并且启动所有容器$ docker-compose up -d # 创建并且后台运行方式启动所有容器$ docker-compose up nginx php mysql # 创建并且启动nginx、php、mysql的多个容器$ docker-compose up -d nginx php mysql # 创建并且已后台运行的方式启动nginx、php、mysql容器$ docker-compose start php # 启动服务$ docker-compose stop php # 停止服务$ docker-compose restart php # 重启服务$ docker-compose build php # 构建或者重新构建服务$ docker-compose rm php # 删除并且停止php容器$ docker-compose down # 停止并删除容器，网络，图像和挂载卷 6.2. 添加快捷命令在开发的时候，我们可能经常使用docker exec -it进入到容器中，把常用的做成命令别名是个省事的方法。 首先，在主机中查看可用的容器： $ docker ps # 查看所有运行中的容器$ docker ps -a # 所有容器 输出的NAMES那一列就是容器的名称，如果使用默认配置，那么名称就是nginx、php、php56、mysql等。 然后，打开~/.bashrc或者~/.zshrc文件，加上： alias dnginx='docker exec -it nginx /bin/sh'alias dphp='docker exec -it php /bin/sh'alias dphp56='docker exec -it php56 /bin/sh'alias dphp54='docker exec -it php54 /bin/sh'alias dmysql='docker exec -it mysql /bin/bash'alias dredis='docker exec -it redis /bin/sh' 下次进入容器就非常快捷了，如进入php容器： $ dphp 6.3. 查看docker网络ifconfig docker0 用于填写extra_hosts容器访问宿主机的hosts地址 7. 使用LogLog文件生成的位置依赖于conf下各log配置的值。 7.1. Nginx日志Nginx日志是我们用得最多的日志，所以我们单独放在根目录log下。 log会目录映射Nginx容器的/var/log/nginx目录，所以在Nginx配置文件中，需要输出log的位置，我们需要配置到/var/log/nginx目录，如： error_log /var/log/nginx/nginx.localhost.error.log warn; 7.2. PHP-FPM日志大部分情况下，PHP-FPM的日志都会输出到Nginx的日志中，所以不需要额外配置。 另外，建议直接在PHP中打开错误日志： error_reporting(E_ALL);ini_set('error_reporting', 'on');ini_set('display_errors', 'on'); 如果确实需要，可按一下步骤开启（在容器中）。 7.2.1. 进入容器，创建日志文件并修改权限：$ docker exec -it php /bin/sh$ mkdir /var/log/php$ cd /var/log/php$ touch php-fpm.error.log$ chmod a+w php-fpm.error.log 7.2.2. 主机上打开并修改PHP-FPM的配置文件conf/php-fpm.conf，找到如下一行，删除注释，并改值为：php_admin_value[error_log] = /var/log/php/php-fpm.error.log 7.2.3. 重启PHP-FPM容器。7.3. MySQL日志因为MySQL容器中的MySQL使用的是mysql用户启动，它无法自行在/var/log下的增加日志文件。所以，我们把MySQL的日志放在与data一样的目录，即项目的mysql目录下，对应容器中的/var/lib/mysql/目录。 slow-query-log-file = /var/lib/mysql/mysql.slow.loglog-error = /var/lib/mysql/mysql.error.log 以上是mysql.conf中的日志文件的配置。 8. 数据库管理本项目默认在docker-compose.yml中不开启了用于MySQL在线管理的phpMyAdmin，以及用于redis在线管理的phpRedisAdmin，可以根据需要修改或删除。 8.1 phpMyAdminphpMyAdmin容器映射到主机的端口地址是：8080，所以主机上访问phpMyAdmin的地址是： http://localhost:8080 MySQL连接信息： host：(本项目的MySQL容器网络) port：3306 username：（手动在phpmyadmin界面输入） password：（手动在phpmyadmin界面输入） 8.2 phpRedisAdminphpRedisAdmin容器映射到主机的端口地址是：8081，所以主机上访问phpMyAdmin的地址是： http://localhost:8081 Redis连接信息如下： host: (本项目的Redis容器网络) port: 6379 9. 在正式环境中安全使用要在正式环境中使用，请： 在php.ini中关闭XDebug调试 增强MySQL数据库访问的安全策略 增强redis访问的安全策略 10. 常见问题10.1. 如何在PHP代码中使用curl？参考这个issue：https://github.com/yeszao/dnmp/issues/91 10.2. Docker使用cron定时任务Docker使用cron定时任务 10.3. Docker容器时间容器时间在.env文件中配置TZ变量，所有支持的时区请看时区列表·维基百科或者PHP所支持的时区列表·PHP官网。 10.4. 如何连接MySQL和Redis服务器这要分两种情况， 第一种情况，在PHP代码中。 // 连接MySQL$dbh = new PDO('mysql:host=mysql;dbname=mysql', 'root', '123456');// 连接Redis$redis = new Redis();$redis-&gt;connect('redis', 6379); 因为容器与容器是expose端口联通的，而且在同一个networks下，所以连接的host参数直接用容器名称，port参数就是容器内部的端口。更多请参考《docker-compose ports和expose的区别》。 第二种情况，在主机中通过命令行或者Navicat等工具连接。主机要连接mysql和redis的话，要求容器必须经过ports把端口映射到主机了。以 mysql 为例，docker-compose.yml文件中有这样的ports配置：3306:3306，就是主机的3306和容器的3306端口形成了映射，所以我们可以这样连接： $ mysql -h127.0.0.1 -uroot -p123456 -P3306$ redis-cli -h127.0.0.1 这里host参数不能用localhost是因为它默认是通过sock文件与mysql通信，而容器与主机文件系统已经隔离，所以需要通过TCP方式连接，所以需要指定IP。 10.5. 容器内的php如何连接宿主机MySQL10.5.1. 宿主机执行ifconfig docker0得到inet就是要连接的ip地址$ ifconfig docker0docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 ... 10.5.2. 运行宿主机Mysql命令行 mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; mysql&gt;flush privileges;// 其中各字符的含义：// *.* 对任意数据库任意表有效// \"root\" \"123456\" 是数据库用户名和密码// '%' 允许访问数据库的IP地址，%意思是任意IP，也可以指定IP// flush privileges 刷新权限信息 10.5.3. 接着直接php容器使用172.0.17.1:3306连接即可","link":"/2021/07/07/Docker%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2dnmp/"},{"title":"leetcod刷题","text":"刷起来 /** * 1.两数之和 * 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 */var twoSum = function(nums, target) { // 创建Map，Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者原始值) 都可以作为一个键或一个值。 const map = new Map() for (let i = 0; i &lt; nums.length; i++) { const complement = target - nums[i] if (map.has(complement)) { return [map.get(complement), i] } else { map.set(nums[i], i) } } return []}// 测试用例let nums = [2, 17, 7, 11, 7, 15], target = 9console.log(twoSum(nums, target))/** * 2.两数相加 * 给出两个非空的链表用来表示两个非负整数。其中，它们给自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字，如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 */function ListNode(val, next) { this.val = (val === undefined ? 0 : val) this.next = (next === undefined ? null : next)}var addTwoNumbers = function(l1, l2) { let dummy = new ListNode() let curr = dummy let carry = 0 while(l1 !== null || l2 !== null) { let sum = 0 if (l1 !== null) { sum += l1.val l1 = l1.next } if (l2 !== null) { sum += l2.val l2 = l2.next } sum += carry curr.next = new ListNode(sum % 10) carry = Math.floor(sum / 10) curr = curr.next } if (carry &gt; 0) { curr.next = new ListNode(carry) } return dummy.next}/** * 3.无重复字符的最长子串 * 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 * 解题方法：sliding window，滑动窗口 */var lengthOfLongestSubstring = function(s) { // 创建一个set const set = new Set() let i = 0, j = 0, maxLength = 0; if (s.length === 0) { return maxLength; } for (i; i &lt; s.length; i++) { // 如果集合不包含当前下标的元素 if (!set.has(s[i])) { set.add(s[i]) maxLength = Math.max(maxLength, set.size) } else { while(set.has(s[i])) { set.delete(s[j]) j++ } set.add(s[i]) } } return maxLength}/** * 4.最长回文子字符串 * 给你一个字符串 s，找到 s 中最长的回文子串。 */var longestPalindrome = function(s) { if (s.length &lt; 2) { return s } let start = 0 let maxLength = 1 // 助手函数，判断左边是否越界，右边是否越界，左边的字符是否等于右边的字符 function expandAroundCenter(left, right) { while(left &gt;= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) { if (right - left + 1 &gt; maxLength) { maxLength = right - left + 1 start = left } left-- right++ } } for(let i = 0; i &lt; s.length; i++) { expandAroundCenter(i - 1, i + 1) expandAroundCenter(i, i + 1) } return s.substring(start, start + maxLength)}/** * 15.三数之和 * 给你一个包含 n 个整数的数组&nbsp;nums，判断&nbsp;nums&nbsp;中是否存在三个元素 a，b，c ，使得&nbsp;a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。 */var threeSum = function(nums) { const result = [] // 给数组排序 nums.sort((a, b) =&gt; a - b) for (let i = 0; i &lt; nums.length - 2; i++) { if (i === 0 || nums[i] !== nums[i - 1]) { let start = i + 1, end = nums.length - 1; while(start &lt; end) { if (nums[i] + nums[start] + nums[end] === 0) { result.push([nums[i], nums[start], nums[end]]) start++ end-- while(start &lt; end &amp;&amp; nums[start] === nums[start - 1]) { start++ } while(start &lt; end &amp;&amp; nums[end] === nums[end + 1]) { end-- } } else if (nums[i] + nums[start] + nums[end] &lt; 0) { // 让当前两数的和更大 start++ } else { // 让当前两数的和变小 end-- } } } } return result}/** * 19.删除链表的倒数第N个节点 * 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 * 进阶：你能尝试使用一趟扫描实现吗？ */var removeNthFromEnd = function(head, n) { // 双指针完成，快慢指针，n1，n2，n2挪n个节点，接下来n1和n2一个一个后移，n2将指向空的时候，n1指向目标要被删除的节点的前一个节点 // 通过dummy节点处理边界问题 let dummy = new ListNode() dummy.next = head let n1 = dummy let n2 = dummy for (let i = 0; i &lt;= n; i++) { n2 = n2.next } while(n2 !== null) { n1 = n1.next n2 = n2.next } // 删除目标节点 n1.next = n1.next.next return dummy.next}/** * 20.有效的括号 * 给定一个只包括 '('，')'，'{'，'}'，'['，']'&nbsp;的字符串 s ，判断字符串是否有效。 * 有效字符串需满足： * 左括号必须用相同类型的右括号闭合。 * 左括号必须以正确的顺序闭合。 */var isValid = function(s) { const mappings = new Map() mappings.set('(', ')') mappings.set('[', ']') mappings.set('{', '}') //通过栈判定匹配情况 const stack = [] for (let i = 0; i&lt; s.length; i++) { if (mappings.has(s[i])) { stack.push(mappings.get(s[i])) } else { if(stack.pop() !== s[i]) { return false } } } return stack.length === 0}/** * 21.合并两个有序链表 * 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点 * 组成的。 */var mergeTwoLists = function(l1, l2) { let curr = new ListNode() // dummy是用来保存结果链表的头部的,链表的头部是dummy.next let dummy = curr while(l1 !== null &amp;&amp; l2 !== null) { if (l1.val &lt; l2.val) { curr.next = l1 l1 = l1.next } else { curr.next = l2 l2 = l2.next } // 结果链表的指针curr向后移动一位 curr = curr.next } // 循环结束后单独判定两个目标链表是否为空，目的是解决不等长情况 if (l1 !== null) { curr.next = l1 } if (l2 !== null) { curr.next = l2 } return dummy.next}/** * 24.两两交换链表中的节点 * 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 * 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 */var swapPairs = function(head) { let dummy = new ListNode() dummy.next = head let current = dummy while(current.next !== null &amp;&amp; current.next.next !== null) { let n1 = current.next let n2 = current.next.next current.next = n2 n1.next = n2.next n2.next = n1 current = n1 } return dummy.next}/** * 49.字母异位词分组 * 给定一个字符串数组，将字母异位词组合在一起。可以按任意顺序返回结果列表。 * 字母异位词指字母相同，但排列不同的字符串。 */var groupAnagrams = function(strs) { // 最优解法，统计 // 通过建立一个长度为26的数组，起始值为0.表示字母出现的次数 if (strs.length === 0) { return [] } // map记录异位词组合 const map = new Map() for (const str of strs) { console.log(str) // 创建长度为26的数组填充0 const characters = Array(26).fill(0) // 通过字母的ascii码映射数组的下表，a-97 for (let i = 0; i &lt; str.length; i++) { // 获取指定下标的字符的ascii码，并减去97映射到数组下标 const ascii = str.charCodeAt(i) - 97 characters[ascii]++ } console.log(characters) const key = characters.join('-') console.log(key) if(map.has(key)) { // map.set(key, map.get(key).push(str)) map.set(key, [...map.get(key), str]) } else { map.set(key, [str]) } } const result = [] for(const array of map) { result.push(array[1]) } return result}// 测试用例let strs = [\"bdddddddddd\",\"bbbbbbbbbbc\"]console.log(groupAnagrams(strs))/** * 53.最大子序和 * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 * 动态规划思想 */var maxSubArray = function(nums) { const memo = [] memo[0] = nums[0] let max = nums[0] for(let i = 1; i &lt; nums.length; i++) { memo[i] = Math.max(nums[i] + memo[i - 1], nums[i]) max = Math.max(max, memo[i]) } return max}/** * 54.螺旋矩阵 * 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 */var spiralOrder = function(matrix) { if (matrix.length === 0) { return [] } let top = 0 let bottom = matrix.length - 1 let left = 0 let right = matrix[0].length - 1 let direction = 'right' let result = [] while(left &lt;= right &amp;&amp; top &lt;= bottom) { if (direction === 'right') { for (let i = left; i &lt;= right; i++) { result.push(matrix[top][i]) } top++ direction = 'down' } else if (direction === 'down') { for (let i = top; i &lt;= bottom; i++) { result.push(matrix[i][right]) } right-- direction = 'left' } else if (direction === 'left') { for (let i = right; i &gt;= left; i--) { result.push(matrix[bottom][i]) } bottom-- direction = 'top' } else if (direction === 'top') { for (let i = bottom; i &gt;= top; i--) { result.push(matrix[i][left]) } left++ direction = 'right' } } return result}/** * 55.跳跃游戏 * 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。 * 判断你是否能够到达最后一个下标。 */var canJump = function(nums) { /* top-down方式 // 动态规划思想 const totalLength = nums.length const memo = Array(totalLength).fill(0) // dp思想 memo[totalLength - 1] = 1 function jump(position) { if (memo[position] === 1) { return true } else if (memo[position] === -1) { return false } // 防止数组越界 const maxJump = Math.min(position + nums[position], totalLength - 1) for (let i = position + 1; i &lt;= maxJump; i++) { const jumpResult = jump(i) if (jumpResult === true) { memo[position] = 1 return true } } memo[position] = -1 return false } return jump(0) */ // bottom-up方式 /* const totalLength = nums.length const memo = Array(totalLength).fill(0) // dp memo[totalLength - 1] = 1 for (let i = totalLength - 2; i &gt;= 0; i--) { const maxJump = Math.min(i + nums[i], totalLength - 1) for (let j = i + 1; j &lt;= maxJump; j++) { if (memo[j] === 1) { memo[i] = 1 break } } } if (memo[0] === 1) { return true } else { return false } */ // 贪心算法 let maxJump = nums.length - 1 for (let i = nums.length - 2; i &gt;= 0; i--) { if (i + nums[i] &gt;= maxJump) { maxJump = i } } return maxJump === 0}/** * 56.合并区间 * 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 */ var merge = function(intervals) { if (intervals.length &lt; 2) { return intervals } // 先排序，保证区间是升序 intervals.sort((a, b) =&gt; a[0] - b[0]) // 用临时数组记录当前最大区间 let curr = intervals[0] let result = [] for (let interval of intervals) { if (curr[1] &gt;= interval[0]) { // 取终止位置的最大值 curr[1] = Math.max(curr[1], interval[1]) } else { result.push(curr) curr= interval } } // 最后一个要判断并保存 if (curr.length != 0) { result.push(curr) } return result}/** * 62.不同路径，经典动态规划题 * 一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？ */var uniquePaths = function(m, n) { const memo = [] for (let i = 0; i &lt; n; i++) { memo.push([]) } for (let row = 0; row &lt; n; row++) { memo[row][0] = 1 } for (let col = 0; col &lt; m; col++) { memo[0][col] = 1 } for (let row = 1; row &lt; n; row++) { for (let col = 1; col &lt; m; col++) { memo[row][col] = memo[row - 1][col] + memo[row][col - 1] } } return memo[n - 1][m - 1]}/** * 66.加一 * 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。 * 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 * 你可以假设除了整数 0 之外，这个整数不会以零开头。 */var plusOne = function(digits) { for (let i = digits.length - 1; i &gt;= 0; i--) { if (digits[i] !== 9) { digits[i]++ return digits } else { digits[i] = 0 } } const result = [1, ...digits] return result}/** * 70.爬楼梯 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ * 注意：给定 n 是一个正整数。 * 动态规划题目 */var climbStairs = function(n) { const memo = [] memo[1] = 1 memo[2] = 2 for (let i = 3; i &lt;= n; i++) { memo[i] = memo[i - 2] + memo[i - 1] } return memo[n]}/** * 73.矩阵置零 * 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。 * 进阶： * 一个直观的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 * 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 * 你能想出一个仅使用常量空间的解决方案吗？ */var setZeroes = function(matrix) { // 用矩阵的第一行和第一列标零的情况 /** * 1.检查并标记第一行和第一列是否有0， * 2.使用第一行和第一列，来标记其余行列是否含0 * 3.接下来，利用第一行和第一列的标0情况，将matrix中的数字标0 * 4.最后，处理第一行和第一列 */ let firstColHasZero = false let firstRowHasZero = false // 检查第一列是否有零 for (let i = 0; i &lt; matrix.length; i++) { if (matrix[i][0] === 0) { firstColHasZero = true } } // 检查第一行是否有0 for (let i = 0; i &lt; matrix[0].length; i++) { if (matrix[0][i] === 0) { firstRowHasZero = true } } // 使用第一行和第一列，来标记其余行列是否含有0 for (let row = 1; row &lt; matrix.length; row++) { for (let col = 1; col &lt; matrix[0].length; col++) { if (matrix[row][col] === 0) { matrix[row][0] = 0 matrix[0][col] = 0 } } } // 接下来，利用第一行和第一列的标零情况，将matrix中的数字标零 for (let row = 1; row &lt; matrix.length; row++) { for (let col = 1; col &lt; matrix[0].length; col++) { if (matrix[row][0] === 0 || matrix[0][col] === 0) { matrix[row][col] = 0 } } } // 最后处理第一行和第一列 if (firstColHasZero) { for (let i = 0; i &lt; matrix.length; i++) { matrix[i][0] = 0 } } if (firstRowHasZero) { for (let i = 0; i &lt; matrix[0].length; i++) { matrix[0][i] = 0 } } return matrix}/** * 83.删除排序链表中的重复元素 * 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。 * 返回同样按升序排列的结果链表。 */var deleteDuplicates = function(head) { let current = head while(current !== null &amp;&amp; current.next !== null) { if (current.val === current.next.val) { current.next = current.next.next } else { current = current.next } } return head}/** * 92.反转链表二 * 给你单链表的头指针 head 和两个整数&nbsp;left 和 right ，其中&nbsp;left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 */var reverseBetween = function(head, m, n) { let prev = null let curr = head // 快进到指定位置 for (let i = 1; i &lt; m; i++) { prev = curr curr = curr.next } let prev2 = prev let curr2 = curr for (let i = m; i &lt;= n; i++) { [curr.next, prev, curr] = [prev, curr, curr.next] } // 考虑从头部开始反转的情况 if (prev2 !== null) { prev2.next = prev } else { head = prev } curr2.next = curr return head}/** * 121.买卖股票的最佳时机 * 给定一个数组 prices ，它的第&nbsp;i 个元素&nbsp;prices[i] 表示一支给定股票第 i 天的价格。 * 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 * 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 */var maxProfit = function(prices) { if (prices.length === 0) { return 0 } // 暂存左半边的最小值，存储当前最大利润 let minPrice = prices[0], maxProfit = 0 for (let i = 0; i &lt; prices.length; i++) { if (prices[i] &lt; minPrice) { minPrice = prices[i] } else if (prices[i] - minPrice &gt; maxProfit) { maxProfit = prices[i] - minPrice } } return maxProfit}/** * 122.买卖股票的最佳时机2 * 给定一个数组 prices ，其中&nbsp;prices[i] 是一支给定股票第 i 天的价格。 * 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票） */var maxProfit2 = function(prices) { if (prices.length === 0) { return 0 } // // 最大利润 // let profit = 0 // // 最低点 // let valley = prices[0] // // 最高点 // let peak = prices[0] // let i = 0 // while( i &lt; prices.length - 1) { // while(i &lt; prices.length - 1 &amp;&amp; prices[i] &gt;= prices[i + 1]) { // i++ // } // valley = prices[i] // while(i &lt; prices.length - 1 &amp;&amp; prices[i] &lt;= prices[i + 1]) { // i++ // } // peak = prices[i] // profit += peak - valley // return profit // } // 贪心算法 let profit = 0 for (let i = 0; i &lt; prices.length - 1; i++) { if (prices[i] &lt; prices[i + 1]) { profit += prices[i + 1] - prices[i] } } return profit}/** * 123.买卖股票的最佳时机3 * 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 * 设计一个算法来计算你所能获取的最大利润。你最多可以完成&nbsp;两笔&nbsp;交易。 * 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 * 动态规划题目 */var maxProfit3 = function(prices) { if (prices.length === 0) { return 0 } // 定义一个二维数组 const dp = Array.from(Array(3), () =&gt; new Array(prices.length)) for (let i = 0; i &lt; prices.length; i++) { dp[0][i] = 0 } for (let i = 0; i &lt; 3; i++) { dp[i][0] = 0 } for (let i = 1; i &lt; 3; i++) { let maxProfit = -prices[0] for (let j = 1; j &lt; prices.length; j++) { dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxProfit) maxProfit = Math.max(maxProfit, dp[i - 1][j] - prices[j]) } } return dp[2][prices.length - 1]}/** * 125.验证回文串 * 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 * 说明：本题中，我们将空字符串定义为有效的回文串。 */// 双指针，从两头往中间缩var isPalindrome = function(s) { s = s.toLowerCase().replace(/[\\W_]/g, '') if (s.length &lt; 2) { return true } let left = 0, right = s.length - 1 while(left &lt; right) { if (s[left] !== s[right]) { return false } left++ right-- } return true}/** * 134.加油站 * 在一条环路上有&nbsp;N&nbsp;个加油站，其中第&nbsp;i&nbsp;个加油站有汽油&nbsp;gas[i]&nbsp;升。 * 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1&nbsp;个加油站需要消耗汽油&nbsp;cost[i]&nbsp;升。你从其中的一个加油站出发，开始时油箱为空。 * 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 * 说明:&nbsp; * 如果题目有解，该答案即为唯一答案。 * 输入数组均为非空数组，且长度相同。 * 输入数组中的元素均为非负数。 */var canCompleteCircuit = function(gas, cost) { let totalGas = 0, totalCost = 0 for (let i = 0; i &lt; gas.length; i++) { totalGas += gas[i] totalCost += cost[i] } if (totalGas &lt; totalCost) { return -1 } let currentGas = 0, start = 0 for (let i = 0; i &lt; gas.length; i++) { currentGas = currentGas - cost[i] + gas[i] if (currentGas &lt; 0) { currentGas = 0 start = i + 1 } } return start}/** * 141.环形链表 * 给定一个链表，判断链表中是否有环。 * 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 * 如果链表中存在环，则返回 true 。 否则，返回 false 。 * 进阶： * 你能用 O(1)（即，常量）内存解决此问题吗？ */var hasCycle = function (head) { // 使用快慢指针，互相追赶来确定是否有环 if (head === null) { return false } let slow = head let fast = head while(fast.next !== null &amp;&amp; fast.next.next !== null) { slow = slow.next fast = fast.next.next if (slow === fast) { return true } } return false}/** * 142.环形链表2 * 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 * 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 * 说明：不允许修改给定的链表。 * 进阶： * 你是否可以使用 O(1) 空间解决此题？ * 弗洛伊德算法 */var detectCycle = function (head) { if (head === null) { return null } let slow = head, fast = head, isCycle = false while (fast.next !== null &amp;&amp; fast.next.next !== null) { slow = slow.next fast =fast.next.next if (slow === fast) { isCycle = true break } } if (!isCycle) { return null } // 快指针回到头部 fast = head while (slow !== fast) { slow = slow.next fast = fast.next } return slow }/** * 153.乘积最大子序列 * 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 */var maxProduct = function(nums) { const maxProductMemo = [] const minProductMemo = [] maxProductMemo[0] = nums[0] minProductMemo[0] = nums[0] let max = nums[0] for (let i = 1; i &lt; nums.length; i++) { maxProductMemo[i] = Math.max(nums[i], nums[i] * maxProductMemo[i - 1], nums[i] * minProductMemo[i - 1]) minProductMemo[i] = Math.min(nums[i], nums[i] * maxProductMemo[i - 1], nums[i] * minProductMemo[i - 1]) max = Math.max(max, maxProductMemo[i]) } return max}/** * 153.寻找旋转排序数组中的最小值 * 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] * 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] * 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 * 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素。 */var findMin = function(nums) { // 二分搜索 if(nums.length === 1) { return nums[0] } let left = 0, right = nums.length - 1 if (nums[right] &gt; nums[0]) { return nums[0] } while (left &lt; right) { let mid = Math.floor(left + (right - left) / 2) if (nums[mid] &gt; nums[mid + 1]) { return nums[mid + 1] } if (nums[mid - 1] &gt; nums[mid]) { return nums[mid] } // 二分 if (nums[mid] &gt; nums[left]) { left = mid + 1 } else { right = mid - 1 } }}/** * 160.相交链表 * 编写一个程序，找出两个单链表相交的起始节点 */var getIntersectionNode = function(headA, headB) { // 考虑两个链表长度不同，可以让两个链表的指针各自走完自身链表后继续走一遍对方的链表，这样可以保证两个指针最终走过的总路程相同 let n1 = headA, n2 = headB while (n1 !== n2) { if (n1 === null) { n1 = headB } else { n1 = n1.next } if (n2 === null) { n2 = headA } else { n2 = n2.next } } return n1}","link":"/2021/08/09/leetcod%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"FlappyBird","slug":"FlappyBird","link":"/tags/FlappyBird/"},{"name":"web前端","slug":"web前端","link":"/tags/web%E5%89%8D%E7%AB%AF/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker-compose","slug":"docker-compose","link":"/tags/docker-compose/"},{"name":"dnmp","slug":"dnmp","link":"/tags/dnmp/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"}]}